// Copyright 2015 Google Inc. All Rights Reserved.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package ginja

// Store dynamically-discovered dependency information for one edge.
type Dyndeps struct {
	used_             bool
	restat_           bool
	implicit_inputs_  []*Node
	implicit_outputs_ []*Node
}

func NewDyndeps() *Dyndeps {
	return &Dyndeps{}
}

// Store data loaded from one dyndep file.  Map from an edge
// to its dynamically-discovered dependency information.
// This is a struct rather than a typedef so that we can
// forward-declare it in other headers.
type DyndepFile map[*Edge]*Dyndeps

// DyndepLoader loads dynamically discovered dependencies, as
// referenced via the "dyndep" attribute in build files.
type DyndepLoader struct {
	state_          *State
	disk_interface_ DiskInterface
}

func NewDyndepLoader(state *State, disk_interface DiskInterface) DyndepLoader {
	return DyndepLoader{
		state_:          state,
		disk_interface_: disk_interface,
	}
}

/*
// Load a dyndep file from the given node's path and update the
// build graph with the new information.  One overload accepts
// a caller-owned 'DyndepFile' object in which to store the
// information loaded from the dyndep file.
func (d *DyndepLoader) LoadDyndeps(node *Node, err *string) bool {
	return d.LoadDyndeps(node, DyndepFile{}, err)
}
*/

// Load a dyndep file from the given node's path and update the
// build graph with the new information.  One overload accepts
// a caller-owned 'DyndepFile' object in which to store the
// information loaded from the dyndep file.
func (d *DyndepLoader) LoadDyndeps(node *Node, ddf DyndepFile, err *string) bool {
	// We are loading the dyndep file now so it is no longer pending.
	node.set_dyndep_pending(false)

	// Load the dyndep information from the file.
	EXPLAIN("loading dyndep file '%s'", node.path())
	if !d.LoadDyndepFile(node, ddf, err) {
		return false
	}

	// Update each edge that specified this node as its dyndep binding.
	out_edges := node.out_edges()
	for _, oe := range out_edges {
		edge := oe
		if edge.dyndep_ != node {
			continue
		}

		ddi, ok := ddf[edge]
		if !ok {
			*err = ("'" + edge.outputs_[0].path() + "' not mentioned in its dyndep file '" + node.path() + "'")
			return false
		}

		ddi.used_ = true
		dyndeps := ddi
		if !d.UpdateEdge(edge, dyndeps, err) {
			return false
		}
	}

	// Reject extra outputs in dyndep file.
	for edge, oe := range ddf {
		if !oe.used_ {
			*err = ("dyndep file '" + node.path() + "' mentions output '" + edge.outputs_[0].path() + "' whose build statement does not have a dyndep binding for the file")
			return false
		}
	}

	return true
}

func (d *DyndepLoader) UpdateEdge(edge *Edge, dyndeps *Dyndeps, err *string) bool {
	// Add dyndep-discovered bindings to the edge.
	// We know the edge already has its own binding
	// scope because it has a "dyndep" binding.
	if dyndeps.restat_ {
		edge.env_.AddBinding("restat", "1")
	}

	// Add the dyndep-discovered outputs to the edge.
	edge.outputs_ = append(edge.outputs_, dyndeps.implicit_outputs_...)
	edge.implicit_outs_ += len(dyndeps.implicit_outputs_)

	// Add this edge as incoming to each new output.
	for _, i := range dyndeps.implicit_outputs_ {
		if old_in_edge := i.in_edge(); old_in_edge != nil {
			// This node already has an edge producing it.  Fail with an error
			// unless the edge was generated by ImplicitDepLoader, in which
			// case we can replace it with the now-known real producer.
			if !old_in_edge.generated_by_dep_loader_ {
				*err = "multiple rules generate " + (*i).path()
				return false
			}
			old_in_edge.outputs_ = nil
		}
		(*i).set_in_edge(edge)
	}

	// Add the dyndep-discovered inputs to the edge.
	edge.inputs_ = append(edge.inputs_[:len(edge.inputs_)-edge.order_only_deps_], dyndeps.implicit_inputs_...)
	edge.implicit_deps_ += len(dyndeps.implicit_inputs_)
	// Add this edge as outgoing from each new input.
	for _, i := range dyndeps.implicit_inputs_ {
		i.AddOutEdge(edge)
	}
	return true
}

func (d *DyndepLoader) LoadDyndepFile(file *Node, ddf DyndepFile, err *string) bool {
	parser := NewDyndepParser(d.state_, d.disk_interface_, ddf)
	return parser.Load(file.path(), err, nil)
}
